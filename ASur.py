#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#************************************************************************
# --- Copyright (c) INRS 2016
# --- Institut National de la Recherche Scientifique (INRS)
# ---
# --- Licensed under the Apache License, Version 2.0 (the "License");
# --- you may not use this file except in compliance with the License.
# --- You may obtain a copy of the License at
# ---
# ---     http://www.apache.org/licenses/LICENSE-2.0
# ---
# --- Unless required by applicable law or agreed to in writing, software
# --- distributed under the License is distributed on an "AS IS" BASIS,
# --- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# --- See the License for the specific language governing permissions and
# --- limitations under the License.
#************************************************************************
#
# generated by wxGlade 0.7.2 on Sun Aug 28 14:09:29 2016
#

"""
Modèle de temps d'arrivée de surverses
"""

__version__ = '1.0'

import datetime
import enum
import os
import sys
import pytz
import optparse
import traceback
import logging

import wx
import wx.lib.masked   as mk
import wx.lib.wordwrap as ww
import wx.lib.agw.hypertreelist as HTL

import ASPlot
import ASParam
import ASModel

#--- Help provider
provider = wx.SimpleHelpProvider()
wx.HelpProvider_Set(provider)

#--- States
GlbStates = enum.Enum('GlbStates', ('started', 'data_loaded'))
GlbModes  = enum.Enum('GlbModes',  ('standard', 'expert'))

hlpTxt = u"""
Détermination de la fenêtre des temps d'arrivée d'une surverse

Principe
======
L'application permet de charger un ou plusieurs jeux de données qui décrivent la dynamique \
des temps d'arrivée des surverses pour un site. 

L'application permet de spécifier un scénario de surverse:
    - en sélectionnant un ou des points de surverse;
    - en spécifiant la plage horaire de la surverse.
La même plage horaire est appliquée à tous les points de surverse sélectionnés. \
Les temps sont spécifiés en heure locale.

Pour chaque point de surverse le graphique montre une ou plusieurs \
fenêtre de temps d'arrivée au site choisi. Pour la période, il montre également une esquisse \
du signal de marée qui est extrait des tables de marées du Pêches et Océan Canada.

Pour chaque scénario de surverse, l'application va déterminer à partir de quand \
le site choisi sera touchée. Elle donne donc les temps d'arrivée. \
Elle ne détermine pas pendant combien de temps le site sera affectée par la surverse.

La qualité de l’eau au site peut continuer d’être d’affectée pendant une certaine période \
de temps après l'arrivée des surverses avant de retrouver une meilleur qualité par les effets combinés \
de la dilution, du transport et de la dégradation des contaminants. On peut toutefois estimer \
que la prochaine marée haute aura nettoyé le site.

L'application permet de charger plusieurs jeux de données et de les comparer.

Interactions
========
Le menu <Fichier/Ouvrir> permet de choisir le répertoire qui contient le(s) jeux de données \
avec lequel travailler. S'il s'agit d'un répertoire qui contient des sous-répertoires de données, alors \
tous les sous-répertoires seront chargés. Sinon, seul le répertoire sélectionné sera chargé.
le menu <Fichier/Ajouter> et <Fichier/Ajouter un répertoire récent> permettent d'ajouter un jeux de données.

Le menue <Paramètres/Marées> permet de choisir quelles marées vont être considérées dans le calcul. \
Celles-ci sont identifiées par le marnage et la durée du cycle et sont triées par marnage. Les marées actives \
sont sauvegardées et relues lorsque le logiciel est relancé.

Il est possible d’agrandir une portion du graphique (zoom) en sélectionnant un rectangle \
avec la souris (click & drag). Le retour en arrière se fait en utilisant la barre d'espacement.

"""

licTxt = u"""
ASur  Version %s
Copyright (c) INRS 2016
Institut National de la Recherche Scientifique (INRS)

Sous licence Apache, Version 2.0 (la "Licence") ;
vous ne pouvez pas utiliser ce fichier, sauf conformément avec la licence.
Vous pouvez obtenir une copie de la Licence sur
       http://www.apache.org/licenses/LICENSE-2.0

Sauf si requis par la loi en vigueur ou par accord écrit, le logiciel distribué sous la licence est distribué "TEL QUEL", SANS GARANTIE NI CONDITION DE QUELQUE NATURE QUE CE SOIT, implicite ou explicite.
Consultez la Licence pour connaître la terminologie spécifique régissant les autorisations et les limites prévues par la licence.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
""" % __version__

appName  = u"ASur"
appTitle = u"Arrivée d'une SURverse"

class ASur(wx.Frame):
    CLC_DELTAS = 300
    CLC_DELTAT = datetime.timedelta(seconds=CLC_DELTAS)

    ID_MDL = [ wx.NewId() for i in xrange(9)]

    def __init__(self, *args, **kwds):
        self.appMode = kwds.pop("appMode", GlbModes.standard)

        wx.Frame.__init__(self, *args, **kwds)

        agwStyle =(HTL.TR_NO_HEADER
                 | HTL.TR_HAS_BUTTONS
                 | HTL.TR_HIDE_ROOT
                 | HTL.TR_AUTO_CHECK_CHILD
                 | HTL.TR_AUTO_CHECK_PARENT)

        self.splt = wx.SplitterWindow(self, wx.ID_ANY)
        self.ssh_lft   = wx.Panel(self.splt, wx.ID_ANY)
        self.ssh_rht   = wx.Panel(self.splt, wx.ID_ANY)
        self.lst_pnts  = HTL.HyperTreeList(self.ssh_lft, wx.ID_ANY, agwStyle=agwStyle)
        self.txt_tini  = wx.StaticText    (self.ssh_rht, wx.ID_ANY, u'Début: ')
        self.ctl_dini  = wx.DatePickerCtrl(self.ssh_rht, wx.ID_ANY, style=wx.DP_DROPDOWN)
        self.ctl_tini  = mk.TimeCtrl      (self.ssh_rht, wx.ID_ANY, format='24HHMM')
        self.txt_tfin  = wx.StaticText    (self.ssh_rht, wx.ID_ANY, u'Fin: ')
        self.ctl_dfin  = wx.DatePickerCtrl(self.ssh_rht, wx.ID_ANY, style=wx.DP_DROPDOWN)
        self.ctl_tfin  = mk.TimeCtrl      (self.ssh_rht, wx.ID_ANY, format='24HHMM')
        self.btn_apply = wx.Button        (self.ssh_rht, wx.ID_APPLY, u'Affiche')
        self.pnl_wx    = ASPlot.ASPlot    (self.ssh_rht, wx.ID_ANY, messenger=self.cb_panel, on_dclick=self.on_data_dclick)
        self.statusbar = self.CreateStatusBar(2)

        self.histCfg = wx.Config('ASur - File history', style=wx.CONFIG_USE_LOCAL_FILE)
        self.prmsCfg = wx.Config('ASur - Parameters',   style=wx.CONFIG_USE_LOCAL_FILE)

        self.__create_menu_bar()
        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU,      self.on_mnu_open,  self.mnu_file_open)
        self.Bind(wx.EVT_MENU,      self.on_mnu_add,   self.mnu_file_add)
        self.Bind(wx.EVT_MENU_RANGE,self.on_mnu_hist, id=wx.ID_FILE1, id2=wx.ID_FILE9)
        self.Bind(wx.EVT_MENU_RANGE,self.on_mnu_xone, id=self.ID_MDL[0], id2=self.ID_MDL[-1])
        self.Bind(wx.EVT_MENU,      self.on_mnu_close, self.mnu_file_close)
        self.Bind(wx.EVT_MENU,      self.on_mnu_quit,  self.mnu_file_quit)
        self.Bind(wx.EVT_MENU,      self.on_mnu_maree, self.mnu_parm_maree)
        self.Bind(wx.EVT_MENU,      self.on_mnu_help,  self.mnu_help_help)
        self.Bind(wx.EVT_MENU,      self.on_mnu_info,  self.mnu_help_info)
        self.Bind(wx.EVT_MENU,      self.on_mnu_about, self.mnu_help_about)
        self.Bind(wx.EVT_BUTTON,    self.on_btn_apply, self.btn_apply)

        self.mnu_states = {
            GlbStates.started  : (
                [self.mnu_file,         # off
                 self.mnu_parm,
                 self.mnu_help],
                [self.mnu_file,         # on
                 self.mnu_help_help,
                 self.mnu_help_about]),
            GlbStates.data_loaded : (
                [],                     # off
                [self.mnu_file,         # on
                 self.mnu_parm,
                 self.mnu_help])
        }
        self.mnuState = None
        self.__set_state(GlbStates.started)

        self.dirname = u''
        self.bbModels = []
        self.bbCycles = []

        #logHndlr = logging.StreamHandler()
        #FORMAT = "%(asctime)s %(levelname)s %(message)s"
        #logHndlr.setFormatter( logging.Formatter(FORMAT) )

        #logger = logging.getLogger("INRS.ASModel.station")
        #logger.addHandler(logHndlr)
        #logger.setLevel(logging.DEBUG)


    def __set_properties(self):
        # ---  Main title
        self.SetTitle(appTitle)
        self.SetSize((600, 800))

        # ---  Spin for the hours
        h = self.ctl_tini.GetSize().height
        self.spn_tini = wx.SpinButton(self.ssh_rht, wx.ID_ANY, wx.DefaultPosition, (-1,h), wx.SP_VERTICAL)
        self.ctl_tini.BindSpinButton( self.spn_tini )
        h = self.ctl_tfin.GetSize().height
        self.spn_tfin = wx.SpinButton(self.ssh_rht, wx.ID_ANY, wx.DefaultPosition, (-1,h), wx.SP_VERTICAL)
        self.ctl_tfin.BindSpinButton( self.spn_tfin )

        # ---  Tree
        self.lst_pnts.AddColumn('Points de surverse')
        self.lst_pnts.SetMainColumn(0)
        self.lst_pnts.SetColumnWidth(0, 180)

        # ---  Status bar
        self.statusbar.SetStatusWidths([-1,-1])
        statusbar_fields = ["Status", "Position"]
        for i, f in enumerate(statusbar_fields):
            self.statusbar.SetStatusText(f, i)

    def __do_layout(self):
        szr_main = wx.BoxSizer(wx.HORIZONTAL)
        szr_lft  = wx.StaticBoxSizer(wx.StaticBox(self.ssh_lft, wx.ID_ANY, u"Points de surverse"), wx.HORIZONTAL)
        szr_rht  = wx.StaticBoxSizer(wx.StaticBox(self.ssh_rht, wx.ID_ANY, u"Plage de surverse"),  wx.VERTICAL)
        szr_data = wx.BoxSizer(wx.HORIZONTAL)
        szr_tini = wx.BoxSizer(wx.HORIZONTAL)
        szr_tfin = wx.BoxSizer(wx.HORIZONTAL)
        szr_plot = wx.StaticBoxSizer(wx.StaticBox(self.ssh_rht, wx.ID_ANY, u"Graphe des temps d'arrivée"), wx.HORIZONTAL)

        szr_lft.Add(self.lst_pnts, 1, wx.EXPAND, 0)

        szr_tini.Add(self.ctl_tini, 1, wx.EXPAND)
        szr_tini.Add(self.spn_tini, 0, wx.EXPAND)
        szr_tfin.Add(self.ctl_tfin, 1, wx.EXPAND)
        szr_tfin.Add(self.spn_tfin, 0, wx.EXPAND)

        szr_data.Add(self.txt_tini, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        szr_data.Add(self.ctl_dini, 2, wx.EXPAND, 0)
        szr_data.Add(szr_tini,      2, wx.EXPAND, 0)
        szr_data.AddSpacer(20)
        szr_data.Add(self.txt_tfin, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        szr_data.Add(self.ctl_dfin, 2, wx.EXPAND, 0)
        szr_data.Add(szr_tfin,      2, wx.EXPAND, 0)
        szr_data.AddSpacer(20)
        szr_data.Add(self.btn_apply,0, wx.ALIGN_RIGHT, 0)

        szr_plot.Add(self.pnl_wx, 1, wx.EXPAND, 0)

        szr_rht.Add(szr_data,    0, wx.EXPAND, 0)
        szr_rht.AddSpacer(5)
        szr_rht.Add(szr_plot,    2, wx.EXPAND, 0)

        self.ssh_lft.SetSizer(szr_lft)
        self.ssh_rht.SetSizer(szr_rht)

        self.splt.SplitVertically(self.ssh_lft, self.ssh_rht, 180)
        self.splt.SetMinimumPaneSize(-100)

        szr_main.Add(self.splt, 1, wx.EXPAND, 0)
        self.SetSizer(szr_main)
        szr_main.Fit(self)
        self.Layout()

    def __create_menu_bar(self):
        # ---  File history
        self.history= wx.FileHistory(5)
        self.history.Load(self.histCfg)
        self.hist_mnu = wx.Menu()
        self.history.UseMenu(self.hist_mnu)
        self.history.AddFilesToMenu()

        # ---  Loaded files
        self.bbmdl_mnu = wx.Menu()

        # ---  Set up menus
        self.menubar = wx.MenuBar()
        self.mnu_file = wx.Menu()
        self.mnu_file_open = wx.MenuItem(self.mnu_file, wx.NewId(), u"Ouvrir...\tCTRL+O", u"Sélectionner le répertoire des données - Ferme toutes les données chargées", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_open)
        self.mnu_file_add  = wx.MenuItem(self.mnu_file, wx.NewId(), u"Ajouter...\tCTRL+P", u"Ajouter un répertoire des données", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_add)
        self.mnu_file.AppendMenu(wx.ID_ANY, u"Ajouter un répertoire récent\tCtrl+R", self.hist_mnu)
        self.mnu_file.AppendSeparator()
        self.mnu_file.AppendMenu(wx.ID_ANY, u"Fermer un jeux de données\tCtrl+W", self.bbmdl_mnu)
        self.mnu_file_close = wx.MenuItem(self.mnu_file, wx.NewId(), u"Fermer tout",  u"Fermer tous les jeux de données", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_close)
        self.mnu_file.AppendSeparator()
        self.mnu_file_quit = wx.MenuItem(self.mnu_file, wx.NewId(), u"Quitter\tCTRL+Q",  u"Quitter l'application", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_quit)
        self.menubar.Append(self.mnu_file, u"Fichier")

        self.mnu_parm = wx.Menu()
        self.mnu_parm_maree = wx.MenuItem(self.mnu_parm, wx.NewId(), u"Marées...\tCTRL+M", u"Sélectionner les marées prise en compte dans le calcul", wx.ITEM_NORMAL)
        self.mnu_parm.AppendItem(self.mnu_parm_maree)
        self.menubar.Append(self.mnu_parm, u"Paramètres")

        self.mnu_help = wx.Menu()
        self.mnu_help_help = wx.MenuItem(self.mnu_help, wx.NewId(), u"Aide...\tF1", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_help)
        self.mnu_help_info = wx.MenuItem(self.mnu_help, wx.NewId(), u"Info...", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_info)
        self.mnu_help_about = wx.MenuItem(self.mnu_help, wx.NewId(), u"À propos...", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_about)
        self.menubar.Append(self.mnu_help, u"Aide")

        self.SetMenuBar(self.menubar)

    def __set_state(self, status):
        for it in self.mnu_states[status][0]:
            if isinstance(it, wx.Menu):
                for m in it.GetMenuItems(): m.Enable(False)
            else:
                it.Enable(False)
        for it in self.mnu_states[status][1]:
            if isinstance(it, wx.Menu):
                for m in it.GetMenuItems(): m.Enable(True)
            else:
                it.Enable(True)
        self.mnuState = status

    def __fillModelMenu(self):
        for item in self.bbmdl_mnu.GetMenuItems():
            self.bbmdl_mnu.DeleteItem(item)
        for id, bbModel in enumerate(self.bbModels):
            fpath = bbModel.getDataDir()
            label = os.path.basename(fpath)
            self.bbmdl_mnu.Append(self.ID_MDL[id], label, help=fpath)

    def __fillTree(self):
        pnts = {}
        for bbModel in self.bbModels:
            for pnt in bbModel.getPointNames():
                pnts.setdefault(pnt, [])
                pnts[pnt].append(bbModel)

        self.lst_pnts.DeleteAllItems()
        root = self.lst_pnts.AddRoot('')
        gname = ''
        for pnt in sorted(pnts.keys()):
            if pnt.split('-')[0] != gname:
                gname = pnt.split('-')[0]
                node = self.lst_pnts.AppendItem(root, gname, ct_type=1)
            child = self.lst_pnts.AppendItem(node, pnt, ct_type=1)

            uniquer = set()
            for bbModel in pnts[pnt]:
                for tide in bbModel.getPointTideNames(pnt):
                    uniquer.add(tide)
            tides = sorted(uniquer)
            tides = [ t for t in tides if t in self.bbCycles ]
            child.SetData(tides)
            if tides:
                if self.appMode is GlbModes.expert:
                    for t in tides:
                        item = self.lst_pnts.AppendItem(child, t, ct_type=1)
            else:
                child.Enable(False)

    def __getCycles(self, bbModel):
        """
        Returns all know cycles contained in the data
        """
        uniquer = set()
        for pnt in bbModel.getPointNames():
            for tide in bbModel.getPointTideNames(pnt):
                uniquer.add(tide)
        return [ item for item in sorted(uniquer) ]

    def __getAllCycles(self):
        """
        Returns all know cycles contained in the data
        """
        uniquer = set()
        for bbModel in self.bbModels:
            for pnt in bbModel.getPointNames():
                for tide in bbModel.getPointTideNames(pnt):
                    uniquer.add(tide)
        return [ item for item in sorted(uniquer) ]

    def __getActivCycles(self, bbModel):
        """
        Returns all the activated cycles
        """
        allCycles = self.__getCycles(bbModel)
        return [ cycle for cycle in allCycles if self.prmsCfg.ReadBool('/ActivCycles/%s' % cycle, True) ]

    def __getAllActivCycles(self):
        """
        Returns all the activated cycles
        """
        allCycles = self.__getAllCycles()
        return [ cycle for cycle in allCycles if self.prmsCfg.ReadBool('/ActivCycles/%s' % cycle, True) ]

    def __getTIni(self):
        """
        Return computation start time in UTC
        """
        d  = self.ctl_dini.GetValue()
        t  = self.ctl_tini.GetValue().split(':')
        dt = datetime.datetime(d.Year, d.Month+1, d.Day, int(t[0]), int(t[1]))
        dt = ASPlot.LOCAL_TZ.localize(dt)
        dt = dt.astimezone(pytz.utc)
        return dt

    def __getTFin(self):
        """
        Return computation end time in UTC
        """
        d  = self.ctl_dfin.GetValue()
        t  = self.ctl_tfin.GetValue().split(':')
        dt = datetime.datetime(d.Year, d.Month+1, d.Day, int(t[0]), int(t[1]))
        dt = ASPlot.LOCAL_TZ.localize(dt)
        dt = dt.astimezone(pytz.utc)
        return dt

    def __getPoints(self, item = None, lvl = 0):
        if not item:
            item = self.lst_pnts.GetRootItem()

        res = []
        if lvl == 0:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
        elif lvl == 1:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
        elif lvl == 2:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
                if res: res = [ [ item.GetText(), res] ]
            elif item.IsChecked():
                res = item.GetData()
                if res: res = [ [ item.GetText(), res] ]
        elif lvl == 3:
            if item.IsChecked():
                res = [ item.GetText() ]
        return res

    def __getPlotData(self, bbModel, dtini, dtfin, pts, do_merge):
        """
        Compute the global arrival time windows
        """
        res = bbModel.xeq(dtini, dtfin, ASur.CLC_DELTAT, pts, do_merge)
        dtmax = dtfin
        for pt, dtaPt in res:
            for dtaTr in dtaPt:
                for dtaXpo in dtaTr:
                    if not dtaXpo: continue
                    dtmax_arr = dtaXpo[-1][0]
                    if dtmax_arr: dtmax = max(dtmax, dtmax_arr)
        ndays = (dtmax - dtini).days + 1
        return res, (dtini, dtini+datetime.timedelta(days=ndays))

    def __getPlotDataZoom(self, bbModel, dtini, dtfin, pts, do_merge):
        """
        Compute the global arrival time windows
        """
        res = []
        point, tides = pts
        for t in tides:
            r = bbModel.xeq(dtini, dtfin, ASur.CLC_DELTAT, [ [point, [t]] ], do_merge)
            res.extend(r)
        dtmax = dtfin
        for pt, dtaPt in res:
            for dtaTr in dtaPt:
                for dtaXpo in dtaTr:
                    if not dtaXpo: continue
                    dtmax_arr = dtaXpo[-1][0]
                    if dtmax_arr: dtmax = max(dtmax, dtmax_arr)
        ndays = (dtmax - dtini).days + 1
        return res, (dtini, dtini+datetime.timedelta(days=ndays))

    def on_data_dclick(self, point):
        if not self.appMode is GlbModes.expert: return

        errMsg = ''
        if not errMsg:
            dtini = self.__getTIni()
            dtfin = self.__getTFin()
            if dtini >= dtfin:
                errMsg = u'Temps invalides: Le temps initial doit être inférieur au temps final'

        if not errMsg:
            pts = None
            for p in self.__getPoints():
                if p[0] == point:
                    pts = [p]
                    break
            if not pts:
                errMsg = u'La sélection de points de surverse est vide'

        if not errMsg:
            wx.BeginBusyCursor()
            try:
                dtmax = dtini
                # ---  With 1 model, do not merge transfer times
                if len(self.bbModels) == 1:
                    bbModel = self.bbModels[0]
                    dtaGlb, (dtmin, dtmax) = self.__getPlotDataZoom(bbModel, dtini, dtfin, pts[0], False)
                    self.pnl_wx.plotZoom(bbModel, dtaGlb, dtini, dtfin, dtmax, title=u'Différentes marées - Différentes vitesses')
                # ---  With many models, merge transfer times and reorganize
                else:
                    dtaGlb = []
                    for bbModel in reversed(self.bbModels):
                        dta, (dtmin_, dtmax_) = self.__getPlotDataZoom(bbModel, dtini, dtfin, pts[0], True)
                        if dtaGlb:
                            for dtaCl, d in zip(dtaGlb, dta):
                                dtaCl[1].extend(d[1])
                        else:
                            dtaGlb = dta
                        dtmax = max(dtmax, dtmax_)
                    self.pnl_wx.plotZoom(self.bbModels[0], dtaGlb, dtini, dtfin, dtmax, title=u'Différentes marées - Différentes dilutions')
            except Exception as e:
                errMsg = '%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = '%s' % str(e)
            finally:
                wx.EndBusyCursor()

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, 'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_btn_apply(self, event):
        errMsg = ''
        if not errMsg:
            dtini = self.__getTIni()
            dtfin = self.__getTFin()
            if dtini >= dtfin:
                errMsg = u'Temps invalides: Le temps initial doit être inférieur au temps final'

        if not errMsg:
            pts = self.__getPoints()
            if len(pts) == 0:
                errMsg = u'La sélection de points de surverse est vide'

        if not errMsg:
            wx.BeginBusyCursor()
            try:
                dtaGlb, dtmax = [], dtini
                # ---  With 1 model, do not merge transfer times
                if len(self.bbModels) == 1:
                    bbModel = self.bbModels[0]
                    dtaGlb, (dtmin, dtmax) = self.__getPlotData(bbModel, dtini, dtfin, pts, False)
                    self.pnl_wx.plotAll(self.bbModels[0], dtaGlb, dtini, dtfin, dtmax, title=u'Différentes vitesses')
                # ---  With many models, merge transfer times and reorganize
                else:
                    for pt in pts:
                        dtaPt = []
                        for bbModel in reversed(self.bbModels):
                            dta, (dtmin_, dtmax_) = self.__getPlotData(bbModel, dtini, dtfin, [pt], True)
                            dtmax = max(dtmax, dtmax_)
                            dtaMdl = dta[0][1]
                            if dtaMdl:
                                dtaPt.append( dtaMdl[0] )
                            else:
                                dtaPt.append( [] )
                        dtaGlb.append( (pt[0], dtaPt) )
                    self.pnl_wx.plotAll(self.bbModels[0], dtaGlb, dtini, dtfin, dtmax, title=u'Différentes dilutions')
            except Exception as e:
                errMsg = '%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = '%s' % str(e)
            finally:
                wx.EndBusyCursor()

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, 'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def __do_mnu_open(self, dirname):
        # ---  Check if allready open
        for bbModel in self.bbModels:
            if dirname == bbModel.getDataDir():
                return
        # ---  Construct model
        self.bbModels.append( ASModel.ASModel(dirname) )
        self.bbModels.sort(key = ASModel.ASModel.getDataDir)
        # ---  Fill activ cycles list
        self.bbCycles = self.__getAllActivCycles()
        # ---  Fill list
        self.__fillTree()
        # ---  Set title
        #dn = os.path.basename(dirname)
        #self.SetTitle(u"%s - %s" % (appTitle, dn))

        self.dirname = dirname
        self.history.AddFileToHistory(self.dirname)
        self.history.Save(self.histCfg)

        self.__set_state(GlbStates.data_loaded)

    def on_mnu_open(self, event):
        errMsg = u''
        dlg = wx.DirDialog(self, u"Répertoire des données", self.dirname)
        if (dlg.ShowModal() == wx.ID_OK):
            dirname = dlg.GetPath()
            if (len(dirname) > 0):
                wx.BeginBusyCursor()
                try:
                    self.bbModels = []
                    subdirs = os.walk(dirname).next()[1]
                    if subdirs:
                        for subdir in subdirs:
                            fullpath = os.path.join(dirname, subdir)
                            self.__do_mnu_open(fullpath)
                    else:
                        self.__do_mnu_open(dirname)
                    self.__fillModelMenu()
                except Exception as e:
                    errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                    #errMsg = str(e)
                finally:
                    wx.EndBusyCursor()
            else:
                errMsg = u'Sélectionner le répertoire de données'
        dlg.Destroy()
        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_add(self, event):
        errMsg = u''
        dlg = wx.DirDialog(self, u"Répertoire des données à ajouter", self.dirname)
        if (dlg.ShowModal() == wx.ID_OK):
            dirname = dlg.GetPath()
            if (len(dirname) > 0):
                wx.BeginBusyCursor()
                try:
                    self.__do_mnu_open(dirname)
                    self.__fillModelMenu()
                except Exception as e:
                    errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                    #errMsg = str(e)
                finally:
                    wx.EndBusyCursor()
            else:
                errMsg = u'Sélectionner un répertoire de données'
        dlg.Destroy()
        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_hist(self, event):
        errMsg = u''
        fileNum = event.GetId() - wx.ID_FILE1
        dirname = self.history.GetHistoryFile(fileNum)
        if (len(dirname) > 0):
            wx.BeginBusyCursor()
            try:
                self.__do_mnu_open(dirname)
                self.__fillModelMenu()
            except Exception as e:
                self.history.RemoveFileFromHistory(fileNum)
                errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = str(e)
            finally:
                wx.EndBusyCursor()
        else:
            errMsg = u'Nom du répertoire de données vide'

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_xone(self, event):
        errMsg = u''
        mnuItem = self.bbmdl_mnu.FindItemById(event.GetId())
        dirname = mnuItem.GetHelp()
        if (len(dirname) > 0):
            wx.BeginBusyCursor()
            try:
                bbModel = next(b for b in self.bbModels if b.getDataDir() == dirname)
                self.bbModels.remove(bbModel)
                self.__fillTree()
                self.__fillModelMenu()
                del bbModel
                if not self.bbModels:
                    self.__set_state(GlbStates.started)
            except Exception as e:
                errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = str(e)
            finally:
                wx.EndBusyCursor()
        else:
            errMsg = u'Nom du répertoire de données vide'

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_close(self, event):
        dlg = wx.MessageDialog(self, u' Êtes-vous sûr(e)? \n', 'Fermer', wx.YES_NO)
        if (dlg.ShowModal() == wx.ID_YES):
            self.bbModels = []
            self.__fillTree()
            self.__fillModelMenu()
            self.__set_state(GlbStates.started)

    def on_mnu_quit(self, event):
        dlg = wx.MessageDialog(self, u' Êtes-vous sûr(e)? \n', 'Fermer', wx.YES_NO)
        if (dlg.ShowModal() == wx.ID_YES):
            self.bbModels = []
            self.Close(True)

    def on_mnu_maree(self, event):
        errMsg = None
        try:
            allCycles = self.__getAllCycles()
            atvCycles = self.__getAllActivCycles()
            dlg = ASParam.ASParam(self)
            dlg.setItems  (allCycles)
            dlg.checkItems(atvCycles)
            if (dlg.ShowModal() == wx.ID_OK):
                atvCycles = dlg.getCheckedItems()

                self.prmsCfg.DeleteGroup('/ActivCycles')
                for cycle in allCycles:
                    self.prmsCfg.WriteBool('/ActivCycles/%s' % cycle, cycle in atvCycles)
                self.prmsCfg.Flush()

                self.bbCycles = self.__getAllActivCycles()
                self.__fillTree()
            dlg.Destroy()
        except Exception as e:
            errMsg = str(e)
        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_help(self, event):
        infoDlg = wx.AboutDialogInfo()
        #infoDlg.Name = appTitle
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Description = ww.wordwrap(hlpTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def on_mnu_info(self, event):
        info = []
        for bbModel in self.bbModels:
            info.append(bbModel.getDataDir())
            info.extend(bbModel.getInfo())
            info.append('-----------------------')
        infoTxt = '\n'.join(info[:-1])
        infoDlg = wx.AboutDialogInfo()
        #infoDlg.Name = appTitle
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Description = ww.wordwrap(infoTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def on_mnu_about(self, event):
        infoDlg = wx.AboutDialogInfo()
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        #infoDlg.Version = __version__
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Developers  = [ u'Yves Secretan (INRS)' ]
        infoDlg.License     = ww.wordwrap(licTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def cb_panel(self, xy):
        try:
            if len(xy) > 0:
                s = []
                dt = xy[0]
                dt = dt.replace(microsecond=0)
                dt = dt.astimezone(ASPlot.LOCAL_TZ)
                s.append( 't={t:s}'.format(t=dt.isoformat(' ')) )
                if len(xy) > 1:
                    h = xy[1]
                    s.append( 'h={h:,.2f}'.format(h=h) )
                    if len(xy) > 2:
                        c = xy[2]
                        s.append( 'c={c:,.2e}'.format(c=c) )
                s = ' : '.join(s)
            else:
                s = ''
            self.statusbar.SetStatusText('Position: %s' % s, 1)
        except Exception as e:
            #print str(e)
            pass

"""
Utilise une fonction plutôt qu'une classe
car l'héritage fait planter cython
"""
def createPaBeauApp(*args, **kwargs):
    # class PaBeauApp(wx.App):
    #   def __init__(self, *args, **kwargs)
    self = wx.App()

    #   def OnInit(self):
    frame = ASur(None, -1, '', *args, **kwargs)
    self.SetTopWindow(frame)
    frame.Show()
    return self, 1

if __name__ == "__main__":
    def main(opt_args = None):
        import logging
        logHndlr = logging.StreamHandler()
        FORMAT = "%(asctime)s %(levelname)s %(message)s"
        logHndlr.setFormatter( logging.Formatter(FORMAT) )

        logger = logging.getLogger("INRS.ASModel")
        logger.addHandler(logHndlr)
        logger.setLevel(logging.INFO)

        # ---  Parse les options
        parser = optparse.OptionParser()
        #parser.add_option("-x", "--expert-mode", dest="xpr", default=False, action='store_true', help="start in expert mode")
        parser.add_option("-x", "--expert-mode", dest="xpr", default=False, action='store_true', help=optparse.SUPPRESS_HELP)

        # --- Parse les arguments de la ligne de commande
        if (not opt_args): opt_args = sys.argv[1:]
        (options, args) = parser.parse_args(opt_args)

        appMode = GlbModes.expert if options.xpr else GlbModes.standard
        app, err = createPaBeauApp(appMode=appMode)
        app.MainLoop()

    main()
