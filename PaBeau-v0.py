#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#************************************************************************
# --- Copyright (c) INRS 2016
# --- Institut National de la Recherche Scientifique (INRS)
# ---
# --- Licensed under the Apache License, Version 2.0 (the "License");
# --- you may not use this file except in compliance with the License.
# --- You may obtain a copy of the License at
# ---
# ---     http://www.apache.org/licenses/LICENSE-2.0
# ---
# --- Unless required by applicable law or agreed to in writing, software
# --- distributed under the License is distributed on an "AS IS" BASIS,
# --- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# --- See the License for the specific language governing permissions and
# --- limitations under the License.
#************************************************************************
#
# generated by wxGlade 0.7.2 on Sun Aug 28 14:09:29 2016
#

"""
Modèle de temps d'arrivée de surverses
"""

__version__ = '1.0'

import datetime
import enum
import os
import sys
import pytz
import optparse
import traceback
import logging

import wx
import wx.lib.masked   as mk
import wx.lib.wordwrap as ww
import wx.lib.agw.hypertreelist as HTL

import PaPlot
import PaParam
import ASModel

#--- Help provider
provider = wx.SimpleHelpProvider()
wx.HelpProvider_Set(provider)

#--- States
GlbStates = enum.Enum('GlbStates', ('started', 'data_loaded'))
GlbModes  = enum.Enum('GlbModes',  ('standard', 'expert'))

hlpTxt = u"""
Détermination de la fenêtre des temps d'arrivée d'une surverse à la plage de la Baie de Beauport

Principe
======
L'application permet de spécifier un scénario de surverse:
    - en sélectionnant un ou des points de surverse;
    - en spécifiant la plage horaire de la surverse.
La même plage horaire est appliquée à tous les points de surverse sélectionnés. \
Les temps sont spécifiés en heure locale.

Pour chaque point de surverse le graphique montre une ou plusieurs \
fenêtre de temps d'arrivée à la plage, en fait une fenêtre par temps \
de transit en rivière. Pour la période, il montre également une esquisse \
du signal de marée qui est extrait des tables de marées du Pêches et Océan Canada.

Pour chaque scénario de surverse, l'application va déterminer à partir de quand \
la plage de la Baie de Beauport serait touchée. Elle donne donc les temps d'arrivée. \
Elle ne détermine pas pendant combien de temps la plage sera affectée par la surverse.

La qualité de l’eau à la plage peut continuer d’être d’affectée pendant une certaine période \
de temps après l'arrivée des surverses avant de retrouver une meilleur qualité par les effets combinés \
de la dilution, du transport et de la dégradation des contaminants.

Interactions
========
Le menu <Fichier/Ouvrir> permet de choisir le répertoire qui contient le jeux de données \
avec lequel travailler.

Le menue <Paramètres/Marées> permet de choisir quelles marées vont être considérées dans le calcul. \
Celles-ci sont identifiées par le marnage et la durée du cycle et sont triées par marnage.

Il est possible d’agrandir une portion du graphique (zoom) en sélectionnant un rectangle \
avec la souris (click & drag). Le retour en arrière se fait en utilisant la barre d'espacement.

"""

licTxt = u"""
PaBeau  Version %s
Copyright (c) INRS 2016
Institut National de la Recherche Scientifique (INRS)

Ce programme est un logiciel libre; vous pouvez le redistribuer \
ou le modifier suivant les termes de la GNU General Public License \
telle que publiée par la Free Software Foundation ; soit la version 3 de la licence, \
soit (à votre gré) toute version ultérieure.

Ce programme est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE GARANTIE; \
sans même la garantie tacite de QUALITÉ MARCHANDE ou d'ADÉQUATION à UN BUT PARTICULIER. \
Consultez la GNU General Public License pour plus de détails.

Vous devez avoir reçu une copie de la GNU General Public License en même temps que ce programme; \
si ce n'est pas le cas, consultez <http://www.gnu.org/licenses>
""" % __version__

appName  = u"PaBeau"
appTitle = u"Temps d'arrivée d'une surverse à la plage de la Baie de Beauport"

class PaBeau(wx.Frame):
    CLC_DELTAS = 300
    CLC_DELTAT = datetime.timedelta(seconds=CLC_DELTAS)

    def __init__(self, *args, **kwds):
        self.appMode = kwds.pop("appMode", GlbModes.standard)

        wx.Frame.__init__(self, *args, **kwds)

        agwStyle =(HTL.TR_NO_HEADER
                 | HTL.TR_HAS_BUTTONS
                 | HTL.TR_HIDE_ROOT
                 | HTL.TR_AUTO_CHECK_CHILD
                 | HTL.TR_AUTO_CHECK_PARENT)

        self.splt = wx.SplitterWindow(self, wx.ID_ANY)
        self.ssh_lft   = wx.Panel(self.splt, wx.ID_ANY)
        self.ssh_rht   = wx.Panel(self.splt, wx.ID_ANY)
        self.lst_pnts  = HTL.HyperTreeList(self.ssh_lft, wx.ID_ANY, agwStyle=agwStyle)
        self.txt_tini  = wx.StaticText    (self.ssh_rht, wx.ID_ANY, u'Début: ')
        self.ctl_dini  = wx.DatePickerCtrl(self.ssh_rht, wx.ID_ANY, style=wx.DP_DROPDOWN)
        self.ctl_tini  = mk.TimeCtrl      (self.ssh_rht, wx.ID_ANY, format='24HHMM')
        self.txt_tfin  = wx.StaticText    (self.ssh_rht, wx.ID_ANY, u'Fin: ')
        self.ctl_dfin  = wx.DatePickerCtrl(self.ssh_rht, wx.ID_ANY, style=wx.DP_DROPDOWN)
        self.ctl_tfin  = mk.TimeCtrl      (self.ssh_rht, wx.ID_ANY, format='24HHMM')
        self.btn_apply = wx.Button        (self.ssh_rht, wx.ID_APPLY, u'Affiche')
        self.pnl_wx    = PaPlot.PaPlot    (self.ssh_rht, wx.ID_ANY, messenger=self.cb_panel, on_dclick=self.on_data_dclick)
        self.statusbar = self.CreateStatusBar(2)

        self.histCfg = wx.Config('PaBeau - File history', style=wx.CONFIG_USE_LOCAL_FILE)
        self.prmsCfg = wx.Config('PaBeau - Parameters',   style=wx.CONFIG_USE_LOCAL_FILE)

        self.__create_menu_bar()
        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU,      self.on_mnu_open,  self.mnu_file_open)
        self.Bind(wx.EVT_MENU_RANGE,self.on_mnu_hist, id=wx.ID_FILE1, id2=wx.ID_FILE9)
        self.Bind(wx.EVT_MENU,      self.on_mnu_close, self.mnu_file_close)
        self.Bind(wx.EVT_MENU,      self.on_mnu_quit,  self.mnu_file_quit)
        self.Bind(wx.EVT_MENU,      self.on_mnu_maree, self.mnu_parm_maree)
        self.Bind(wx.EVT_MENU,      self.on_mnu_help,  self.mnu_help_help)
        self.Bind(wx.EVT_MENU,      self.on_mnu_info,  self.mnu_help_info)
        self.Bind(wx.EVT_MENU,      self.on_mnu_about, self.mnu_help_about)
        self.Bind(wx.EVT_BUTTON,    self.on_btn_apply, self.btn_apply)

        self.mnu_states = {
            GlbStates.started  : (
                [self.mnu_file,         # off
                 self.mnu_parm,
                 self.mnu_help],
                [self.mnu_file,         # on
                 self.mnu_help_help,
                 self.mnu_help_about]),
            GlbStates.data_loaded : (
                [],                     # off
                [self.mnu_file,         # on
                 self.mnu_parm,
                 self.mnu_help])
        }
        self.mnuState = None
        self.__set_state(GlbStates.started)

        self.dirname = u''
        self.bbModel = None
        self.bbCycles = []

        #logHndlr = logging.StreamHandler()
        #FORMAT = "%(asctime)s %(levelname)s %(message)s"
        #logHndlr.setFormatter( logging.Formatter(FORMAT) )

        #logger = logging.getLogger("INRS.ASModel.station")
        #logger.addHandler(logHndlr)
        #logger.setLevel(logging.DEBUG)


    def __set_properties(self):
        # ---  Main title
        self.SetTitle(appTitle)
        self.SetSize((600, 800))

        # ---  Spin for the hours
        h = self.ctl_tini.GetSize().height
        self.spn_tini = wx.SpinButton(self.ssh_rht, wx.ID_ANY, wx.DefaultPosition, (-1,h), wx.SP_VERTICAL)
        self.ctl_tini.BindSpinButton( self.spn_tini )
        h = self.ctl_tfin.GetSize().height
        self.spn_tfin = wx.SpinButton(self.ssh_rht, wx.ID_ANY, wx.DefaultPosition, (-1,h), wx.SP_VERTICAL)
        self.ctl_tfin.BindSpinButton( self.spn_tfin )

        # ---  Tree
        self.lst_pnts.AddColumn('Points de surverse')
        self.lst_pnts.SetMainColumn(0)
        self.lst_pnts.SetColumnWidth(0, 180)

        # ---  Status bar
        self.statusbar.SetStatusWidths([-1,-1])
        statusbar_fields = ["Status", "Position"]
        for i, f in enumerate(statusbar_fields):
            self.statusbar.SetStatusText(f, i)

    def __do_layout(self):
        szr_main = wx.BoxSizer(wx.HORIZONTAL)
        szr_lft  = wx.StaticBoxSizer(wx.StaticBox(self.ssh_lft, wx.ID_ANY, u"Points de surverse"), wx.HORIZONTAL)
        szr_rht  = wx.StaticBoxSizer(wx.StaticBox(self.ssh_rht, wx.ID_ANY, u"Plage de surverse"),  wx.VERTICAL)
        szr_data = wx.BoxSizer(wx.HORIZONTAL)
        szr_tini = wx.BoxSizer(wx.HORIZONTAL)
        szr_tfin = wx.BoxSizer(wx.HORIZONTAL)
        szr_plot = wx.StaticBoxSizer(wx.StaticBox(self.ssh_rht, wx.ID_ANY, u"Graphe des temps d'arrivée"), wx.HORIZONTAL)

        szr_lft.Add(self.lst_pnts, 1, wx.EXPAND, 0)

        szr_tini.Add(self.ctl_tini, 1, wx.EXPAND)
        szr_tini.Add(self.spn_tini, 0, wx.EXPAND)
        szr_tfin.Add(self.ctl_tfin, 1, wx.EXPAND)
        szr_tfin.Add(self.spn_tfin, 0, wx.EXPAND)

        szr_data.Add(self.txt_tini, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        szr_data.Add(self.ctl_dini, 2, wx.EXPAND, 0)
        szr_data.Add(szr_tini,      2, wx.EXPAND, 0)
        szr_data.AddSpacer(20)
        szr_data.Add(self.txt_tfin, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0)
        szr_data.Add(self.ctl_dfin, 2, wx.EXPAND, 0)
        szr_data.Add(szr_tfin,      2, wx.EXPAND, 0)
        szr_data.AddSpacer(20)
        szr_data.Add(self.btn_apply,0, wx.ALIGN_RIGHT, 0)

        szr_plot.Add(self.pnl_wx, 1, wx.EXPAND, 0)

        szr_rht.Add(szr_data,    0, wx.EXPAND, 0)
        szr_rht.AddSpacer(5)
        szr_rht.Add(szr_plot,    2, wx.EXPAND, 0)

        self.ssh_lft.SetSizer(szr_lft)
        self.ssh_rht.SetSizer(szr_rht)

        self.splt.SplitVertically(self.ssh_lft, self.ssh_rht, 180)
        self.splt.SetMinimumPaneSize(-100)

        szr_main.Add(self.splt, 1, wx.EXPAND, 0)
        self.SetSizer(szr_main)
        szr_main.Fit(self)
        self.Layout()

    def __create_menu_bar(self):
        # ---  File history
        self.history= wx.FileHistory(5)
        self.history.Load(self.histCfg)
        self.hist_mnu = wx.Menu()
        self.history.UseMenu(self.hist_mnu)
        self.history.AddFilesToMenu()

        # ---  Set up menus
        self.menubar = wx.MenuBar()
        self.mnu_file = wx.Menu()
        self.mnu_file_open = wx.MenuItem(self.mnu_file, wx.NewId(), u"Ouvrir...\tCTRL+O", u"Sélectionner le répertoire des données", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_open)
        self.mnu_file.AppendMenu(wx.ID_ANY, u"Ouvrir un répertoire récent\tCtrl+R", self.hist_mnu)
        self.mnu_file.AppendSeparator()
        self.mnu_file_close = wx.MenuItem(self.mnu_file, wx.NewId(), u"Fermer\tCTRL+W",  u"Fermer les répertoires", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_close)
        self.mnu_file.AppendSeparator()
        self.mnu_file_quit = wx.MenuItem(self.mnu_file, wx.NewId(), u"Quitter\tCTRL+Q",  u"Quitter l'application", wx.ITEM_NORMAL)
        self.mnu_file.AppendItem(self.mnu_file_quit)
        self.menubar.Append(self.mnu_file, u"Fichier")

        self.mnu_parm = wx.Menu()
        self.mnu_parm_maree = wx.MenuItem(self.mnu_parm, wx.NewId(), u"Marées...\tCTRL+M", u"Sélectionner les marées prise en compte dans le calcul", wx.ITEM_NORMAL)
        self.mnu_parm.AppendItem(self.mnu_parm_maree)
        self.menubar.Append(self.mnu_parm, u"Paramètres")

        self.mnu_help = wx.Menu()
        self.mnu_help_help = wx.MenuItem(self.mnu_help, wx.NewId(), u"Aide...\tF1", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_help)
        self.mnu_help_info = wx.MenuItem(self.mnu_help, wx.NewId(), u"Info...", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_info)
        self.mnu_help_about = wx.MenuItem(self.mnu_help, wx.NewId(), u"À propos...", "", wx.ITEM_NORMAL)
        self.mnu_help.AppendItem(self.mnu_help_about)
        self.menubar.Append(self.mnu_help, u"Aide")

        self.SetMenuBar(self.menubar)

    def __set_state(self, status):
        for it in self.mnu_states[status][0]:
            if isinstance(it, wx.Menu):
                for m in it.GetMenuItems(): m.Enable(False)
            else:
                it.Enable(False)
        for it in self.mnu_states[status][1]:
            if isinstance(it, wx.Menu):
                for m in it.GetMenuItems(): m.Enable(True)
            else:
                it.Enable(True)
        self.mnuState = status

    def __fillTree(self):
        self.lst_pnts.DeleteAllItems()
        root = self.lst_pnts.AddRoot('')
        gname = ''
        if self.bbModel:
            pnts = self.bbModel.getPointNames()
            for pnt_name in pnts:
                if pnt_name.split('-')[0] != gname:
                    gname = pnt_name.split('-')[0]
                    node = self.lst_pnts.AppendItem(root, gname, ct_type=1)
                child = self.lst_pnts.AppendItem(node, pnt_name, ct_type=1)

                tides = self.bbModel.getPointTideNames(pnt_name)
                tides = [ t for t in tides if t in self.bbCycles ]
                child.SetData(tides)
                if tides:
                    if self.appMode is GlbModes.expert:
                        for t in tides:
                            item = self.lst_pnts.AppendItem(child, t, ct_type=1)
                else:
                    child.Enable(False)

    def __getAllCycles(self):
        """
        Returns all know cycles contained in the data
        """
        uniquer = set()
        for pnt in self.bbModel.getPointNames():
            for tide in self.bbModel.getPointTideNames(pnt):
                uniquer.add(tide)
        return [ item for item in sorted(uniquer) ]

    def __getAllActivCycles(self):
        """
        Returns all the activated cycles
        """
        allCycles = self.__getAllCycles()
        return [ cycle for cycle in allCycles if self.prmsCfg.ReadBool('/ActivCycles/%s' % cycle, True) ]

    def __getTIni(self):
        """
        Return computation start time in UTC
        """
        d  = self.ctl_dini.GetValue()
        t  = self.ctl_tini.GetValue().split(':')
        dt = datetime.datetime(d.Year, d.Month+1, d.Day, int(t[0]), int(t[1]))
        dt = PaPlot.LOCAL_TZ.localize(dt)
        dt = dt.astimezone(pytz.utc)
        return dt

    def __getTFin(self):
        """
        Return computation end time in UTC
        """
        d  = self.ctl_dfin.GetValue()
        t  = self.ctl_tfin.GetValue().split(':')
        dt = datetime.datetime(d.Year, d.Month+1, d.Day, int(t[0]), int(t[1]))
        dt = PaPlot.LOCAL_TZ.localize(dt)
        dt = dt.astimezone(pytz.utc)
        return dt

    def __getPoints(self, item = None, lvl = 0):
        if not item:
            item = self.lst_pnts.GetRootItem()

        res = []
        if lvl == 0:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
        elif lvl == 1:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
        elif lvl == 2:
            if item.HasChildren():
                for child in item.GetChildren():
                    r = self.__getPoints(item=child, lvl=lvl+1)
                    res.extend(r)
                if res: res = [ [ item.GetText(), res] ]
            elif item.IsChecked():
                res = item.GetData()
                if res: res = [ [ item.GetText(), res] ]
        elif lvl == 3:
            if item.IsChecked():
                res = [ item.GetText() ]
        return res

    def __getPlotData(self, dtini, dtfin, pts, do_merge):
        """
        Compute the global arrival time windows
        """
        res = self.bbModel.xeq(dtini, dtfin, PaBeau.CLC_DELTAT, pts, do_merge)
        dtmax = dtfin
        for pt, dtaPt in res:
            for dtaTr in dtaPt:
                for dtaXpo in dtaTr:
                    if not dtaXpo: continue
                    dtmax_arr = dtaXpo[-1][0]
                    if dtmax_arr: dtmax = max(dtmax, dtmax_arr)
        ndays = (dtmax - dtini).days + 1
        return res, (dtini, dtini+datetime.timedelta(days=ndays))

    def __getPlotDataZoom(self, dtini, dtfin, pts, do_merge):
        """
        Compute the global arrival time windows
        """
        res = []
        point, tides = pts
        for t in tides:
            r = self.bbModel.xeq(dtini, dtfin, PaBeau.CLC_DELTAT, [ [point, [t]] ], do_merge)
            res.extend(r)
        dtmax = dtfin
        for pt, dtaPt in res:
            for dtaTr in dtaPt:
                for dtaXpo in dtaTr:
                    if not dtaXpo: continue
                    dtmax_arr = dtaXpo[-1][0]
                    if dtmax_arr: dtmax = max(dtmax, dtmax_arr)
        ndays = (dtmax - dtini).days + 1
        return res, (dtini, dtini+datetime.timedelta(days=ndays))

    def on_data_dclick(self, point):
        if not self.appMode is GlbModes.expert: return

        errMsg = ''
        if not errMsg:
            dtini = self.__getTIni()
            dtfin = self.__getTFin()
            if dtini >= dtfin:
                errMsg = u'Temps invalides: Le temps initial doit être inférieur au temps final'

        if not errMsg:
            pts = None
            for p in self.__getPoints():
                if p[0] == point:
                    pts = [p]
                    break
            if not pts:
                errMsg = u'La sélection de points de surverse est vide'

        if not errMsg:
            wx.BeginBusyCursor()
            #try:
            dta, (dtmin, dtmax) = self.__getPlotDataZoom(dtini, dtfin, pts[0], False)
            self.pnl_wx.plotZoom(self.bbModel, dta, dtini, dtfin, dtmax)
            #except Exception as e:
            #    errMsg = '%s' % str(e)
            #finally:
            wx.EndBusyCursor()

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, 'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_btn_apply(self, event):
        errMsg = ''
        if not errMsg:
            dtini = self.__getTIni()
            dtfin = self.__getTFin()
            if dtini >= dtfin:
                errMsg = u'Temps invalides: Le temps initial doit être inférieur au temps final'

        if not errMsg:
            pts = self.__getPoints()
            if len(pts) == 0:
                errMsg = u'La sélection de points de surverse est vide'

        if not errMsg:
            wx.BeginBusyCursor()
            try:
                dta, (dtmin, dtmax) = self.__getPlotData(dtini, dtfin, pts, False)
                self.pnl_wx.plotAll(self.bbModel, dta, dtini, dtfin, dtmax)
            except Exception as e:
                errMsg = '%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = '%s' % str(e)
            finally:
                wx.EndBusyCursor()

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, 'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def __do_mnu_open(self, dirname):
        # ---  Construct model
        self.bbModel = ASModel.ASModel(dirname)
        # ---  Fill activ cycles list
        self.bbCycles = self.__getAllActivCycles()
        # ---  Fill list
        self.__fillTree()
        # ---  Set title
        dn = os.path.basename(dirname)
        self.SetTitle(u"%s - %s" % (appTitle, dn))

        self.dirname = dirname
        self.history.AddFileToHistory(self.dirname)
        self.history.Save(self.histCfg)

        self.__set_state(GlbStates.data_loaded)

    def on_mnu_open(self, event):
        errMsg = u''
        dlg = wx.DirDialog(self, u"Répertoire des données", self.dirname)
        if (dlg.ShowModal() == wx.ID_OK):
            dirname = dlg.GetPath()
            if (len(dirname) > 0):
                wx.BeginBusyCursor()
                try:
                    self.__do_mnu_open(dirname)
                except Exception as e:
                    errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                    #errMsg = str(e)
                finally:
                    wx.EndBusyCursor()
            else:
                errMsg = u'Sélectionner le répertoire de données'
        dlg.Destroy()
        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_hist(self, event):
        errMsg = u''
        fileNum = event.GetId() - wx.ID_FILE1
        dirname = self.history.GetHistoryFile(fileNum)
        if (len(dirname) > 0):
            wx.BeginBusyCursor()
            try:
                self.__do_mnu_open(dirname)
            except Exception as e:
                self.history.RemoveFileFromHistory(fileNum)
                errMsg = u'%s\n%s' % (str(e), traceback.format_exc())
                #errMsg = str(e)
            finally:
                wx.EndBusyCursor()
        else:
            errMsg = u'Nom du répertoire de données vide'

        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_close(self, event):
        dlg = wx.MessageDialog(self, u' Êtes-vous sûr(e)? \n', 'Fermer', wx.YES_NO)
        if (dlg.ShowModal() == wx.ID_YES):
            self.bbModel = None
            self.__fillTree()
            self.__set_state(GlbStates.started)

    def on_mnu_quit(self, event):
        dlg = wx.MessageDialog(self, u' Êtes-vous sûr(e)? \n', 'Fermer', wx.YES_NO)
        if (dlg.ShowModal() == wx.ID_YES):
            self.bbModel = None
            self.Close(True)

    def on_mnu_maree(self, event):
        errMsg = None
        try:
            allCycles = self.__getAllCycles()
            atvCycles = self.__getAllActivCycles()
            dlg = PaParam.PaParam(self)
            dlg.setItems  (allCycles)
            dlg.checkItems(atvCycles)
            if (dlg.ShowModal() == wx.ID_OK):
                atvCycles = dlg.getCheckedItems()

                self.prmsCfg.DeleteGroup('/ActivCycles')
                for cycle in allCycles:
                    self.prmsCfg.WriteBool('/ActivCycles/%s' % cycle, cycle in atvCycles)
                self.prmsCfg.Flush()

                self.bbCycles = self.__getAllActivCycles()
                self.__fillTree()
            dlg.Destroy()
        except Exception as e:
            errMsg = str(e)
        if errMsg:
            dlg = wx.MessageDialog(self, errMsg, u'Erreur', wx.OK | wx.ICON_ERROR)
            dlg.ShowModal()
            dlg.Destroy()

    def on_mnu_help(self, event):
        infoDlg = wx.AboutDialogInfo()
        #infoDlg.Name = appTitle
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Description = ww.wordwrap(hlpTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def on_mnu_info(self, event):
        bbModel  = self.bbModel
        info = []
        info.append(bbModel.getDataDir())
        info.extend(bbModel.getInfo())
        infoTxt = '\n'.join(info)
        infoDlg = wx.AboutDialogInfo()
        #infoDlg.Name = appTitle
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Description = ww.wordwrap(infoTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def on_mnu_about(self, event):
        infoDlg = wx.AboutDialogInfo()
        infoDlg.Name = '\n'.join(['%s %s' % (appName, __version__), appTitle])
        #infoDlg.Version = __version__
        infoDlg.Copyright = u'(C) 2016 INRS'
        infoDlg.Developers  = [ u'Yves Secretan (INRS)' ]
        infoDlg.License     = ww.wordwrap(licTxt, 450, wx.ClientDC(self))
        wx.AboutBox(infoDlg)

    def cb_panel(self, xy):
        try:
            if len(xy) > 0:
                s = []
                dt = xy[0]
                dt = dt.replace(microsecond=0)
                dt = dt.astimezone(PaPlot.LOCAL_TZ)
                s.append( 't={t:s}'.format(t=dt.isoformat(' ')) )
                if len(xy) > 1:
                    h = xy[1]
                    s.append( 'h={h:,.2f}'.format(h=h) )
                    if len(xy) > 2:
                        c = xy[2]
                        s.append( 'c={c:,.2e}'.format(c=c) )
                s = ' : '.join(s)
            else:
                s = ''
            self.statusbar.SetStatusText('Position: %s' % s, 1)
        except Exception as e:
            #print str(e)
            pass

"""
Utilise une fonction plutôt qu'une classe
car l'héritage fait planter cython
"""
def createPaBeauApp(*args, **kwargs):
    # class PaBeauApp(wx.App):
    #   def __init__(self, *args, **kwargs)
    self = wx.App()

    #   def OnInit(self):
    frame = PaBeau(None, -1, '', *args, **kwargs)
    self.SetTopWindow(frame)
    frame.Show()
    return self, 1

if __name__ == "__main__":
    def main(opt_args = None):
        import logging
        logHndlr = logging.StreamHandler()
        FORMAT = "%(asctime)s %(levelname)s %(message)s"
        logHndlr.setFormatter( logging.Formatter(FORMAT) )

        logger = logging.getLogger("INRS.ASModel")
        logger.addHandler(logHndlr)
        logger.setLevel(logging.INFO)

        # ---  Parse les options
        parser = optparse.OptionParser()
        #parser.add_option("-x", "--expert-mode", dest="xpr", default=False, action='store_true', help="start in expert mode")
        parser.add_option("-x", "--expert-mode", dest="xpr", default=False, action='store_true', help=optparse.SUPPRESS_HELP)

        # --- Parse les arguments de la ligne de commande
        if (not opt_args): opt_args = sys.argv[1:]
        (options, args) = parser.parse_args(opt_args)

        appMode = GlbModes.expert if options.xpr else GlbModes.standard
        app, err = createPaBeauApp(appMode=appMode)
        app.MainLoop()

    main()
